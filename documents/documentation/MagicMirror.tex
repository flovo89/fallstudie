\documentclass[a4paper, 11pt]{article}

% deutsche Silbentrennung
\usepackage[ngerman]{babel}

% wegen deutschen Umlauten
\usepackage[]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[hidelinks]{hyperref}
\usepackage{glossaries}

% for code listing
\usepackage{listings}

\usepackage{graphicx}
\graphicspath{ {./Pictures/} }

\usepackage[backend=bibtex,style=trad-plain]{biblatex}
\bibliography{Bibliography.bib}

% Title Page
\title{Magic Mirror}
\author{Florian Vogel}

\makeglossaries
\newglossaryentry{opensource}
{
	name=Opensource,
	description={Software die von Dritten eingesehen, gelesen und bearbeitet werden kann}
}
\newglossaryentry{sd-card}
{
	name=SD Karte,
	description={Secure Digital Memory card, auf deutsch sichere digitale Speicherkarte}
}
\newglossaryentry{lcd}
{
	name=LCD,
	description={Liquid crystal display, auf deutsch Flüssigkristallanzeige}
}
\newglossaryentry{vga}
{
	name=VGA,
	description={Video graphics array, Schnittstelle für Bildübertragung}
}
\newglossaryentry{dvi}
{
	name=DVI,
	description={Digital visual interface, auf deutsch Digitale visuelle Schnittstelle zum übertragen von Videodaten}
}
\newglossaryentry{hdmi}
{
	name=HDMI,
	description={High definition multimedia interface, auf deutsch hochauflösende Multimedia-Schnittstelle}
}
\newglossaryentry{wlan}
{
	name=WLAN,
	description={Wireless local area network, auf deutsch drahtloses lokales Netzwerk}
}
\newglossaryentry{ssid}
{
	name=SSID,
	description={Service set identifier, Name eines WLAN Netzwerks}
}
\newglossaryentry{mqtt}
{
	name=MQTT,
	description={Message Queuing Telemetry Transport, ein offenes Nachrichtenprotokoll um zwischen Maschinen Nachrichten auszutauschen}
}
\newglossaryentry{bash}
{
	name=Bash,
	description={Befehls Sprache im UNIX Umfeld}
}
\newglossaryentry{pm2}
{
	name=pm2,
	description={Es handelt sich um einen node.js Prozess Manager}
}
\newglossaryentry{nodejs}
{
	name=Node.js,
	description={Es handelt sich um eine JavaScript Laufzeitumgebung}
}
\newglossaryentry{node-red}
{
	name=Node-Red,
	description={Tool um verschieden Hardware zusammen zu verknüpfen}
}
\newglossaryentry{url}
{
	name=URL,
	description={Uniform resource locator, Identifikation und Lokalisation einer bestimmten Ressource}
}
\newglossaryentry{rest-api}
{
	name=Rest API,
	description={Representional state transfer für Application programing interface}
}
\newglossaryentry{json}
{
	name=JSON,
	description={JavaScript Object Notation, kompaktes Datenformat in einer einfachen lesbaren Textform}
}
\newglossaryentry{http}{
	name=HTTP,
	description={Hypertext transfer protocol, zustandsloses Protokoll zur Übertragung von Daten}
}
\newglossaryentry{dmips}{
	name=DMIPS,
	description={Dhyrostone mega instructions pro second, Angabe der Instruktionen pro Sekunde eines Prozessorkerns}
}
\newglossaryentry{usb}{
	name=USB,
	description={Universal serial bus, häufig benutzter serieller Bus für Datenübertragung, beispielsweise von Speicherchips}
}
\newglossaryentry{jtag}{
	name=JTAG,
	description={Joint Test Action Group, Standard zum Testen und Debuggen von integrierten Schaltungen}
}
\newglossaryentry{openocd}{
	name=OpenOCD,
	description={Open on-chip debugger, wird verwendet über Hardwareadapter für beispielsweise Debugging von Controllern}
}
\newglossaryentry{qos}{
	name=QOS,
	description={Levels für MQTT Übertragung: 0 $\rightarrow$ nur einmal, 1 $\rightarrow$ mindestens einmal, 2 $\rightarrow$ genau einmal}
}

\begin{document}
	
\maketitle
\thispagestyle{empty}

\newpage

\tableofcontents
\newpage

\printglossaries
\newpage


\section{Einführung}
Ein Magic Mirror ist ein optisch ansprechendes Anzeigegerät. Es handelt sich um ein Spiegel mit integriertem Bildschirm, wobei es sich bei dem Spiegel um einen sogenannten Spionspiegel handelt. Er ist von einer Seite möglichst reflektierend und von der anderen Seite möglichst durchlässig.
Mit dem verbauten Bildschirm ergeben sich beinahe unbegrenzte Möglichkeiten um Informationen zu präsentieren und diese ansprechend darzustellen. Dadurch passt ein Magic Mirror mit passendem Design gut in einen Wohnbereich.
\\Nun, was soll denn auf solch einem Spiegel angezeigt werden? Natürlich gibt es einige Klassiker, wie zum Beispiel die aktuelle Zeit. Die Möglichkeiten lassen aber viel mehr zu. Es ist beispielsweise auch denkbar jeweils den nächsten Zug von Bern nach Zürich auf dem Magic Mirror anzuzeigen. 
\\Die Interessen für Informationen werden sich mit Sicherheit ändern über die Zeit. Das bedingt eine Konfigurationsmöglichkeit für den Benutzer des Spiegels, mit welcher er anzeigende Informationen ändern kann. Diese genannte Modularität zu erreichen ist eines der Ziele in dieser Semesterarbeit. Weiter soll am Ende ein funktionierender Prototyp eines Magic Mirrors vollendet sein, welcher im Heimbereich eingesetzt wird.

\newpage

\section{Zielsetzung}
Das erste und am höchsten gewichtete Ziel ist das Erstellen eines fertigen Prototypes. Dies wird in folgende Teilschritte unterteilt.
\begin{itemize}
	\item Einfache Anzeigeelemente auf dem Spiegel, wie beispielsweise die Uhrzeit, das Wetter oder einen Kalender.
	\item Energiesparmodus, dabei wird der Bildschirm über einen externen Infrarotsensor ein- und ausgeschalten.
	\item Modul auf welches über mobile Applikation zugegriffen werden kann.
	\item Eine Android Applikation um auf obengenanntes Modul zugreifen zu können.
	\item Sprachsteuerung welche vom Google Assistant gemacht wird.
\end{itemize}
Die genannte Punkte werden schrittweise umgesetzt. Somit hat der letzte Punkt die niedrigste Priorität und wird als optional erachtet.

\newpage

\section{Ausgangslage}
Die Idee des Magic Mirror ist bekannt. Es gibt bereits zahlreiche Versionen davon online zum Nachbau. Es gibt Vorschläge für das Spiegelglas, den Bildschirm, die Recheneinheit, sogar wie der Rahmen des Spiegels aufgebaut werden kann. Deshalb ist es grundsätzlich einmal notwendig, in diesem Dschungel von Ideen eine gute Zusammensetzung zu finden.
\\Sehr prominent tritt dabei ein \Gls{opensource} Projekt auf, welches sich MagicMirror\textsuperscript{2} nennt
\cite{MagicMirror:2019:Online}. Es ist das einzig verfügbare Projekt, welches modular aufgebaut ist und zudem von einer grossen Community unterstützt wird. Deshalb muss als erstes der Einsatz dieses Projekts abgewogen werden.

\subsection{Bewertungskriterien \Gls{opensource} Projekt}
Um zu evaluieren, ob mit dem \Gls{opensource} ProjMein Standortekt MagicMirror\textsuperscript{2} weitergearbeitet werden kann oder ein komplett eigenständiger Ansatz gewählt werden muss, werden folgende Bewertungskriterien genauer analysiert:
\begin{itemize}
	\item Modularität und Erweiterbarkeit
	\item Einarbeitungszeit
	\item Hardwareeinsatz
\end{itemize}
Die folgenden drei Unterkapitel behandeln kurz diese Punkte jeweils für das \Gls{opensource} Projekt, sowie die komplette Eigenentwicklung. Dabei werden Bewertungen angegeben zwischen 1-10, wobei 10 sehr gut ist.

\subsubsection{Modularität und Erweiterbarkeit}
Die Startseite des \Gls{opensource} Projekts wirbt bereits mit grosser Modularität. Wie gross diese ist, zeigt sich durch die Liste der bereits implementierten Erweiterungen, welche auch auf dem Magic Mirror angezeigt werden können. Bereits mehrere hundert solcher Zusatzmodule können eingebunden werden \cite{MagicMirrorModules:2019:Online}. 
\\Die Erweiterbarkeit ist ebenfalls gut, da die Einbindung der einzelnen Module über eine zentrale Stelle (eine Konfigurationsdatei) gemacht werden kann. 
\\Bewertung: 8 $\rightarrow$ keine Informationen darüber, wie gut Module getestet wurden
\\
\\Bei einer Eigenentwicklung muss von Begin klar die Modularität und Erweiterbarkeit berücksichtigt werden. Dies ist gut machbar, da es beim Designen noch keine weiteren Abhängigkeiten gibt. Jedoch ist dies mit Zusatzaufwand verbunden.
\\Bewertung: 5 $\rightarrow$ die Modularität zu gewährleisten bedeutet aber ein grosser Mehraufwand

\subsubsection{Einarbeitungszeit}
Das \Gls{opensource} Projekt rühmt sich damit, auch für Leute ohne nennenswerten technischen Hintergrund einsetzbar zu sein. Diese Aussage bestätigt sich, denn innerhalb einer Stunde ist es möglich, das Projekt auf einem vorbereiteten Raspberry Pi (Raspian auf \Gls{sd-card}) lauffähig zu haben und mit der Grundkonfiguration zu betreiben. Deshalb wird die Einarbeitungszeit als klein eingeschätzt.
\\Bewertung: 8 $\rightarrow$ da Einarbeitung in Modulbearbeitung noch dazukommt
\\
\\Bei der Eigenentwicklung verhält sich die Einarbeitungszeit unterschiedlich je nach verwendeter Methode. Was jedoch sicherlich stark ins Gewicht fällt ist die Konzeptfindung, welche vom Vorwissen abhängt. Dadurch kann die Einarbeitungszeit minimiert werden, jedoch steigt damit sicherlich die Zeit der Konzeptphase.
\\Bewertung: 6 $\rightarrow$ Konzeptphase kann sehr lange dauern

\subsubsection{Hardwareeinsatz}
Die verwendete Hardware des \Gls{opensource} Projekts ist nicht definiert. Das Projekt wurde adaptiert um auf Smartphones und Tablets zu laufen, ist aber auch auf einem Rapberry Pi 2 oder Raspberry Pi 3 verwendbar. Diese Portabilität ist optimal, da in dieser Semesterarbeit eine low-cost Hardwareplatform verwendet werden soll.
\\Bewertung: 8 $\rightarrow$ da es auf den meisten gängigen Platformen läuft, aber nicht auf allen (z.b. Probleme beim Raspberry Pi 1)
\\
\\Bei einer Eigenentwicklung ist der Einsatz der Hardware frei und kann eingeplant werden. Eine low-cost Hardwareplatform zu verwenden stellt kein Problem dar.
\\Bewertung: 10 $\rightarrow$ Projekt kann auf Hardware angepasst werden

\subsection{Designentscheid}
Anhand der Bewertung aus den vorangehenden Kapiteln fällt der Entscheid klar zu Gunsten vom \Gls{opensource} Projekt aus. Das bedeutet, dass als Platform für die Software das MagicMirror\textsuperscript{2} Projekt verwendet wird. Von dieser Grundlage aus, werden die nötigen Anpassungen und Erweiterungen gemacht in den einzelnen Modulen.

\newpage

\section{Aufbau}
Unter einem Kapitel mit dem Namen Aufbau können mehrere Erwartungshaltungen zutreffen. Zum einen sicherlich der Aufbau des Magic Mirrors aus Sicht der verwendeten Materialien und Baugruppen. Zum anderen, und das ist für diese Semesterarbeit das Relevante, der Aufbau der Software und deren Zusammenspiel mit der Hardware. Um jedoch das erstgenannte nicht komplett aussenvor zu lassen, hier ein Sinnbild wie der Magic Mirror aufgebaut wird. Darauf zu sehen ist der benötigte Bildschirm, das Spionglas und ein Rahmen.
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{MagicMirror_Building.png}
\caption{Bauelemente für den Magic Mirror \cite{MagicMirror:2019:Online}}
\end{figure}

\subsection{Auswahl Hardware}
Die Auswahl der Hardware beinhaltet mehrere Einzelteile. Die folgenden Unterkapitel gehen auf die verschiedenen Teile ein. Zur Veranschaulichung jedoch vorweg eine Übersicht über die Komponenten.
\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{HardwareOverview.png}
\caption{Hardware Komponentenübersicht}
\end{figure}

\subsubsection{Bildschirm}
Der Bildschirm ist für den Magic Mirror natürlich zentral. Jedoch ist bei der Auswahl nicht besonders viel zu beachten. Bei dieser Semesterarbeit wird ein 24 Zoll \Gls{lcd} Monitor verwendet, der einen \Gls{dvi} Anschluss hat und noch kein \Gls{hdmi} unterstützt. Die Auswahl fällt aufgrund des Projektbudgets auf diesen Monitor. Er war gratis verfügbar und ist nicht weiter in Gebrauch. Allfällige Inkompatibilitäten können durch Adapterkabel (\Gls{hdmi} $\rightarrow$ \Gls{dvi}) gelöst werden. Der Bildschirm wird durch ein Netzgerät mit 230 Volt betrieben.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{MagicMonitor.jpeg}
	\caption{24" Monitor von Magic}
\end{figure}

\subsubsection{Hauptrechner}
Wichtig ist für den Hauptrechner, eine einfache Anbindung an das Heimnetzwerk zu ermöglichen. Weiter muss direkt eine Video Schnittstelle wie \Gls{hdmi}, \Gls{dvi} oder \Gls{vga} vorhanden sein. Dies funktioniert alles mit einem Raspberry Pi 3 sehr gut, die Netzwerkverbindung sogar auch kabellos mittels Onboard-\Gls{wlan} Chip. Weiter wird das \Gls{opensource} Projekt von einer grossen Community auf dem Raspberry Pi eingesetzt, was ein grosser Pluspunkt im Falle von Fragen mit dem Projekt ist. Ein weiterer Pluspunkt des Raspberry Pi's ist die Verfügbarkeit und die tiefen Kosten. Diese Gründe machen ein Raspberry Pi 3 Model B zum Hauptrechner in dieser Semesterarbeit.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{RaspberryPi.jpg}
	\caption{Raspberry Pi 3 Model B}
\end{figure}

\subsubsection{Infrarot Präsenzmelder}
Wie in der Zielsetzung erwähnt, soll der Magic Mirror möglichst Energieeffizient sein. Der grösste Energieverbrauch liegt sicherlich beim Betreiben des Monitors. Deshalb soll dieser automatisch ausschalten, wenn niemand zu Hause ist. Diese Detektion kann mit einem Infrarot Präsenzmelder gemacht werden. Aus Kostengründen wird der HC-SR501 eingesetzt. Dieser bietet die Möglichkeit, über ein Potentiometer die Sensitivität einzustellen um eine optimale Anpassung an den Einsatzraum zu gewährleisten. 
\\Der Melder funktioniert ab einer Speisespannung von 3.3V. Bei einer Detektion wird ein Puls am Ausgangspin generiert.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.2\textwidth]{InfraredPir.png}
	\caption{Infrarot Präsenzmelder HC-SR501}
\end{figure}

\subsubsection{Hilfsrechner}
Um den erwähnten Puls vom Infrarot Präsenzmelder zu verarbeiten und einen Befehl an den Magic Mirror zu senden, muss noch eine weitere Recheneinheit vorhanden sein. Natürlich könnte auch das Raspberry Pi diese Aufgabe übernehmen. Jedoch müsste dann der Präsenzmelder direkt über ein Kabel verbunden sein mit dem Magic Mirror. Dies ist nicht wünschenswert, da der Präsenzmelder entfernt vom Magic Mirror aufgestellt soll, um Bewegungen im Raum zu erkennen bevor der Betrachter den Magic Mirror sieht. Damit bleibt genügend Zeit um den Bildschirm zu starten und der Betrachter findet den aktiven Magic Mirror vor.
\\Diese Aufgabe der Verarbeitung von einem Puls erfordert keine aufwändigen Berechnungen. Wichtig ist aber, dass der Hilfsrechner eine Möglichkeit hat ins Netzwerk zu kommen um mit dem Magic Mirror zu kommunizieren. Der ESP32 erfüllt diese Anforderung sehr gut, da er einen \Gls{wlan} Chip integriert. Weiter ist das Board sehr kostengünstig erwerbbar. Es handelt sich um einen Chip mit zwei Kernen und 600 \Gls{dmips}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.2\textwidth]{Esp32.png}
	\caption{ESP32 Board mit Microcontroller und \Gls{wlan}}
\end{figure}

\subsubsection{\Gls{wlan} Router}
Die Kommunikation soll in einem Heimnetz funktionieren, wobei eine Verbindung zum Internet bestehen muss, um alle Funktionalitäten des Magic Mirrors ausschöpfen zu können. Da beispielsweise der Infrarot Präsenzmelder nicht kabelgebunden installiert werden soll, muss ein wireless Netz vorhanden sein, sprich \Gls{wlan}. Es kann auch ein Hotspot von einem mobilen Gerät erstellt werden um das Netz herzustellen. Der Magic Mirror, wie auch der Infrarot Präsenzmelder verbinden sich jedoch auf eine fix eingestellte \Gls{ssid}.

\subsubsection{Laptop}
Der Laptop im System wird verwendet um Konfigurationen des Magic Mirror zu ändern. Der Vorgang ist so, dass eine SSH Verbindung zum Raspberry Pi aufgebaut wird, wo die Konfiguration angepasst werden kann.

\subsubsection{Handy}
Eine Android Applikation wird gebaut, um mit dem Magic Mirror interagieren zu können. Mindestens die Version Android Kitkat 4.4 wird dafür benötigt. Dies ist bei Geräten neuer als 2013 standardmässig gegeben und dadurch wird eine grosse Unterstützung erreicht.

\subsection{Auswahl Software}
Auf verschiedenen Teilen im System läuft unterschiedliche Software. Die Eigenentwicklungen oder Erweiterungen an bestehender Software sind im Bild unten aufgeführt. Die einzelnen Softwareteile sind in den folgenden Kapiteln detailierter beschrieben und erläutert. Hier ist bloss eine Übersicht gegeben.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{SoftwareOverview.png}
	\caption{System Software Overview}
\end{figure}

\subsubsection{Raspian auf Raspberry Pi}
Der einfachste Weg um einen Desktop als Ausgabe zu haben, ist die Raspian Desktop Distribution für das Raspberry Pi zu verwenden. In diesem Projekt wird die aktuellste Version von Raspian Stretch vom 13. November 2018 verwendet, welche die Kernelversion 4.14 beinhaltet.

\subsubsection{MagicMirror\textsuperscript{2}}
Das MagicMirror\textsuperscript{2} kann direkt von GIT geklont werden. Die Möglichkeit besteht, dies direkt vom Raspberry Pi zu machen. Um aber das Projekt nicht direkt auf dem Raspberry Pi konfigurieren zu müssen besteht die Variante mittels Kopiervorgängen über das Netzwerk einzelne Konfigurationsinhalte auf dem Laptop anzupassen und anschliessend auf das Raspberry Pi zu kopieren. Durch die grosse Community des Projekts ergibt sich ungefähr monatlich ein neues Stablerelease, was einfach mit \textit{git pull} upgedatet werden kann.

\subsubsection{MQTT Broker}
Auf dem Raspberry Pi wird der wohl bekannteste MQTT Broker verwendet. Namentlich der Mosquitto Broker. Die Installation ist sehr einfach und kann über den üblichen Paketmanager abgehandelt werden. 

\subsubsection{\Gls{node-red}}
\Gls{node-red} wird verwendet, um den externen Infrarot Präsenzmelder in das System zu integrieren und auf dessen publifizierte Nachrichten zu agieren. Der Dienst ist erreichbar im Netzwerk unter dem Port 1880. Das heisst mit \textit{http://magicmirror:1880} wird der Dienst erreicht und dessen Verhalten kann geändert werden. Dabei ist "magicmirror" der Netzwerkname vom Raspberry Pi.

\subsubsection{Android Applikation}
Die Entwicklung einer Android Applikation ist am besten unterstützt mit dem Android-Studio. Dabei engt man die Unterstützung auf Android Geräte ein, was jedoch in diesem Projekt kein Problem ist.

\subsubsection{ESP-IDF Programm}
Um die Funktionalitäten vom ESP32 Microcontroller zu benutzen ist ein Framework sehr hilfreich. \textit{Espressif IoT Development Framework} \cite{ESP-IDF:2019:Online} ist das meistbenutzte und bietet neben Benutzung der IO Pins auch direkte Netzwerkinteraktion über \Gls{wlan}, sogar das \Gls{mqtt} Protokoll ist im Framework implementiert und bereit zur Verwendung.

\newpage

\section{Magic Mirror auf dem Raspberry Pi}
Wie bereits beschrieben, wird die \Gls{opensource} Software von MagicMirror\textsuperscript{2} als Grundlage verwendet. Deshalb wird hier als erstes der Ablauf beschrieben um diese Software auf dem Raspberry Pi aufzusetzen. Dabei wird davon ausgegangen, dass das Raspberry Pi bereits mit einer bootbaren \Gls{sd-card} versehen ist.

\subsection{Aufsetzen von MagicMirror\textsuperscript{2}}
Es gibt ein vorbereitetes \Gls{bash} Skript, mit dem die Installation automatisch ausgeführt wird. Der Befehl dafür ist:
\vspace{0.2cm}\\
\textit{pi@magicmirror bash -c "\$(curl -sL https://raw.githubusercontent.com/MichMich/\\MagicMirror/master/installers/raspberry.sh)"}
\vspace{0.2cm}
\\Die Installation erstellt im \textit{~/home/pi} einen Ordner mit dem Namen \textit{MagicMirror}, welcher das ganze Projekt beinhaltet.
\\Mit einem Startup-Skript kann der Projekt einfach beim Booten gestartet werden. Das Skript hat folgenden Inhalt:
\vspace{0.2cm}\\
\textit{cd ~/MagicMirror\\DISPLAY=:0 npm start}
\vspace{0.2cm}
\\Es trägt den Namen \textit{mm.sh} und wird mit dem Tool \textit{\gls{pm2}} zum Raspberry Bootprozess hinzugefügt.
\\Nach diesen kurzen Schritten wird bereits beim Starten des Raspberry Pi's automatisch der MagicMirror\textsubscript{2} gestartet mit der Default-Konfiguration, welche folgendermassen daherkommt:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.42\textwidth]{DefaultDislpayMagicMirror.png}
	\caption{Standardanzeige vom MagicMirror\textsubscript{2}}
\end{figure}

\subsection{Integration \Gls{node-red} und \Gls{mqtt}}
Der \Gls{mqtt} Broker kann über den Paketmanager geholt werden. Folgender Befehl ist dafür nötig:
\vspace{0.2cm}\\
\textit{pi@magicmirror sudo apt-get install -y mosquitto mosquitto-clients}
\vspace{0.2cm}
\\Danach ist er gestartet und kann von \Gls{node-red} verwendet werden. Erst muss aber auch \Gls{node-red} aufgesetzt werden. Dies kann auch automatisiert erfolgen mit dem Aufruf von: 
\vspace{0.2cm}\\
\textit{pi@magicmirror bash <(curl -sL https://raw.githubusercontent.com/\\node-red/raspbian-deb-package/master/resources/update-nodejs-and-nodered)}
\vspace{0.2cm}
\\Nach erfolgter Installation kann \Gls{node-red} zum Autostart hinzugefügt werden mit dem Befehl:
\vspace{0.2cm}\\
\textit{pi@magicmirror sudo systemctl enable nodered.service}
\vspace{0.2cm}
\\Sobald \Gls{node-red} läuft, kann der grafische Designer erreicht werden über die \Gls{url} \textit{http://magicmirror:1880}. Dort wird schlussendlich die ganze Funktionalität, welche \Gls{node-red} übernimmt beschrieben. Folgendes wird gefordert:
\begin{itemize}
	\item Subscriben an Topic von Infrarot Präsenzmelder.
	\item Nachricht im Topic prüfen.
	\item Trigger für Zeitmessung.
	\item Entscheiden ob Bildschirm an- oder ausgeschaltet werden soll.
	\item Entsprechendes Skript aufrufen.
\end{itemize}
Die geforderten Punkte können grafisch folgendermassen dargestellt werden in \Gls{node-red}:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{NodeRedImplementation.png}
	\caption{\Gls{node-red} grafische Implementation}
\end{figure}
Der dargestellte Ablauf ist nicht komplex. Links ist mit dem \textit{IrSensor} die Registration auf dem Topic \textit{/topic/magicmirror/irsensor} gemacht unter Localhost, da der \Gls{mqtt} auf demselben Gerät läuft. Mit dem Block \textit{topic\char`_check} wird geprüft, ob eine neue Nachricht mit dem Inhalt "irsensor on" erhalten wurde. Alles andere wird ignoriert. Falls eine solche Nachricht erhalten wurde, wird vom \textit{trigger 20s} eine Nachricht mit dem Inhalt "on" an den \textit{switch} gesendet, welcher dann \textit{ScreenOn} ausführt. Falls nach 20 Sekunden keine weitere Nachricht mit "irsensor on" beim \textit{trigger 20s} angelangt ist, sendet er automatisch ein "off" zum \textit{switch}, welcher dann \textit{ScreenOff} ausführt. \textit{ScreenOn} führt folgendes Kommando aus um den Bildschirm einzuschalten:\vspace{0.2cm}\\
\textit{tvservice -p \&\& sudo chvt 6 \&\& sudo chvt 7}
\vspace{0.2cm}
\\Beim \textit{ScreenOff} ist es der folgende Befehl um den Bildschirm auszuschalten:\vspace{0.2cm}\\
\textit{tvservice -o}
\vspace{0.2cm}

\subsection{Implementation eigenes MagicMirror\textsuperscript{2} Modul}
Auf dem Magic Mirror sollen mittels einer Android Applikation Notizen geschrieben und gelesen werden können. Beim Durchsuchen nach einem passenden Modul welches dies bereits anbietet ist folgendes hervorgekommen: \textit{MMM-Memo} \cite{MMM-Memo:2019:Online}.
\\Jedoch erfüllt die Implementation dieses Modules noch nicht alle Anforderungen, welche sind:  
\begin{itemize}
	\item \Gls{rest-api} wird angeboten als Schnittstelle zum Modul.
	\item Mehrere Notizgruppen könne hinzugefügt werden. Hier gewünscht sind \textit{TODO} und \textit{Shopping}.
	\item Ansprechend gestaltbar.
\end{itemize}
Der erste Punkt wird nicht unterstützt. Das Modul erwartet neue Notizen als Teil der \Gls{url}, als Beispiel um Brot auf die Shoppingliste zu schreiben müsste folgender Zugriff gemacht werden:
\vspace{0.2cm}\\
\textit{http://magicmirror:8080/AddMemo?memoTitle=SHOPPING\&item=Brot\&level=INFO}\vspace{0.2cm}
\\Um es dann wieder zu entfernen, braucht es folgenden Aufruf:\vspace{0.2cm}\\
\textit{http://magicmirror:8080/DisplayMemo?memoTitle=SHOPPING\&item=1}
\vspace{0.2cm}\\
Dabei muss die Übersicht über die einzelnen Notizen behalten werden, da sie jeweils nur noch über deren Index (siehe 1 für Brot) angesprochen werden können. Dies soll nicht Aufgabe der Android Applikation sein.
\\Die Lösung um dies zu Umgehen ist die Implementation einer \Gls{rest-api}, welche jeweils den kompletten Satz an Notizen zurückliefert oder überschreibt. Folgende Zugriffe werden implementiert:
\vspace{0.2cm}\\
To get all notes: \textit{http://magicmirror:8080/GetCompleteNote}\\
To write all notes:
\textit{http://magicmirror:8080/AddCompleteNote}\\
To delete all notes:
\textit{http://magicmirror:8080/DeleteAllNotes}
\vspace{0.2cm}
\\Die Notizen werden als \Gls{json} übertragen. Dabei werden \Gls{http}-Get Befehle für die Zugriffe \textit{GetCompleteNote} und \textit{DeleteAllNotes} verwendet und ein \Gls{http}-Post Befehl für den Befehl \textit{AddCompleteNote} mit dem \Gls{json}-Objekt im Body. Das \Gls{json}-Objekt sieht wie folgt aus:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{JsonExample.png}
	\caption{\Gls{json} Beispiel}
\end{figure}
\\Die einzelnen Notizen werden in einem Array abgelegt. Beim aufgeführten Beispiel werden Brot und Salat zur Gruppe \textit{Shopping} und die Aufgabe Wohnung putzen zur Gruppe \textit{TODO} hinzugefügt.
\\
\\Die nötigen Erweiterungen an dem Modul belaufen sich auf ein einzelnes JavaScript-File, wo zusätzliche Behandlungen gemacht werden müssen, je nach dem welche Anfrage kommt. Dabei werden die bisherigen (wo die ganze Information in der \textit{url} vorhanden ist), weiter unterstützt.

\newpage
\subsection{Anpassen der Anzeigeelemente auf dem Magic Mirror}
Diese Anpassungen können sehr einfach behandelt werden. Beim Starten des MagicMirror\textsuperscript{2} wird eine Konfigurationsdatei gelesen, welche alle Daten über die zu ladenden Module beinhaltet. Es handelt sich um folgende Datei:
\vspace{0.2cm}\\
\textit{/home/pi/MagicMirror/config/config.js}\vspace{0.2cm}
\\Die einzelnen Module werden darin als \Gls{json}-Objekte beschrieben.
Alle verwendeten Module sind im untenstehenden Bild aufgeführt:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.75\textwidth]{MagicMirrorScreenshot.png}
	\caption{Magic Mirror Screenshot mit allen Modulen}
\end{figure}

\newpage
\section{Applikation für Präsenzdetektion}
\subsection{Framework Übersicht}
Mit dem Framework von Espressif \cite{ESP-IDF:2019:Online} ist eine sehr umfängliche Basis gegeben, um Funktionalitäten auf dem ESP32 Microcontroller zu programmieren. Neben Zugriffen auf die Peripherien des Controllers, sind verschiedene Protokolle im Framework integriert, FreeRTOS kann eingebunden werden, wie auch ein Monitoring Dienst, der als Ausgabekonsole verwendet werden kann. Als Übersicht das Bild:
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{EspressifOverview.png}
	\caption{ESP32 Framework Übersicht}
\end{figure}
\\Zudem hat das Entwicklungsboard direkt einen eingebauten \Gls{usb}-\Gls{jtag} Adapter, wie auch eine \Gls{openocd} Debugschnittstelle.

\newpage
\subsection{Ablauf des Programmes}
Der schrittweise Ablauf des Programmes ist in folgendem Diagramm dargestellt.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{ESP32Sequence.png}
	\caption{ESP32 Softwareablauf}
\end{figure}
\\Als Beispiel wird der C-Code aufgeführt, um eine Detektion des Infrarot Präsenzmelders mittels \Gls{mqtt} zu publizieren:
\begin{lstlisting}
char buf[20];
strcpy(buf, "irsensor on"); 
esp_mqtt_client_publish(client, TOPIC_PATH_SENSOR, buf, 0, 0, 0);
\end{lstlisting}
Dabei ist die Funktion \textit{esp\char`_mqtt\char`_client\char`_publish} Teil des Frameworks und erwartet als Übergabeparameter ein Handle vom initialisierten \Gls{mqtt}-Client, das Topic (in dem Fall \textit{/topic/magicmirror/irsensor}), die Daten (\textit{irsensor on}), die Länge der Daten (falls kein String gesendet wird), die \Gls{qos} (hier nur einmal) und ein Flag ob die Nachricht bei einem neuen Subscriber gleich vom Broker gesendet werden soll (hier nicht eingeschaltet).

\newpage
\section{Android Applikation für Notizen}
Die Aufgabe der mobilen Android Applikation ist das bedienen der beschriebenen \Gls{rest-api} Schnittstelle des Magic Mirrors um Notizen zu senden und zu verwalten. Wie erwähnt wird die Applikation mit Hilfe von Android-Studio entwickelt. 

\subsection{App Bedienung}
Der Benutzer muss einfach zwischen den verschiedenen Notizgruppen navigieren können. Wünschenswert ist dies mit einer Wischbewegung zu machen, da es intuitiv ist. Android-Studio bietet bereits solche Projekte als Einstiegspunkt an. Als Grundlage hat das sogenannte \textit{Tabbed Activity} gedient, was bereits seitliche Scrollingeffekte mit einer Actionbar integriert. 
\\Die finale Applikation kann somit zwischen den verschiedenen Notizgruppen mit links und rechts Wischen wechseln. Siehe untenstehendes Bild für die Veranschaulichung.
\begin{figure}[htb]
	\centering
	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[scale=0.12]{AppTodos.png}
		\caption{App TODOs}
	\end{minipage}
	%\hfill
	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[scale=0.12]{AppShopping.png}
		\caption{App Shopping}
	\end{minipage}
\end{figure}
\\Die drei ersichtlichen Buttons haben folgende Funktionen, aufgeführt auch von oben nach unten:
\begin{itemize}
	\item Download von Magic Mirror $\rightarrow$ Aktualisiert Notizen auf der App mit den Notizen auf dem Magic Mirror.
	\item Upload auf Magic Mirror $\rightarrow$ Aktualisiert die Notizen vom Magic Mirror mit den angepassten Notizen auf der App.
	\item Printscreen $\rightarrow$ Speichert lokal einen Printscreen der aktuellen Ansicht, um Notizen auch ausserhalb des Heimnetzes zur Verfügung zu haben.
\end{itemize}

\newpage
\subsection{App Programmierung}
Die Funktionalität des Apps ist überschaubar. Um trotzdem eine gewisse Flexibilität zu erreichen wurde die Software folgendermassen aufgebaut.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{AppClassDiagram.png}
	\caption{Klassendiagramm Android App}
\end{figure}
\\Sehr auffällig ist dabei die doppelte Verwendung eines Interfaces auf verschiedenen Ebenen. Jedoch definiert das Interface \textit{IReceptionNotifier} eine Callback-Funktion, die einen String als Argument beinhaltet. Dies wird auf beiden Ebenen benötigt. 
\\Die Kommunikation mit dem Magic Mirror geschieht in den untersten Netzwerk Klassen (\textit{NetworkGet} und \textit{NetworkPost}). Diese werden jeweils von einem eigenen Backgroundtask gehandelt, sobald eine Netzwerkkommunikation erwartet wird. Dies um nicht die Benutzereingaben auf dem Userinterface zu behindern.
\\Eine Ebene darüber, bei der \textit{Communication} Klasse wird das Parsen von den \Gls{json} Objekten durchgeführt, um dann eine Liste mit Strings an die \textit{MainActivity} weiterzuleiten. Diese Liste wird dann dem Benutzer angezeigt.

\newpage
\section{Google Assistant}
Ein zusätzliches Feature für den Magic Mirror ist die Spracherkennung. Nötig dazu ist bloss ein Mikrophon. Um den Magic Mirror anzuweisen Musik zu spielen, soll ebenfalls ein Lautsprecher eingebunden werden. Da mit dem Raspberry Pi 3 die Unterstützung für Bluetooth vorhanden ist, kann sogar ein Bluetooth-Lautsprecher verwendet werden.

\subsection{Evaluation}
Als Mikrophon wird ein Low-cost \Gls{usb} Mikrophon von Rondaful verwendet, welches in untenstehendem Bild gezeigt ist.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.2\textwidth]{UsbMicrophone.png}
	\caption{\Gls{usb} Mikrophon}
\end{figure}
Als Bluetooth-Lautsprecher wird ein etwas teureres Gerät verwendet, nämlich der protable Bluetooth-Speaker Charge 3 von JBL.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{JblCharge3.png}
	\caption{Bluetooth Speaker JBL Charge 3}
\end{figure}

\newpage

\printbibliography

\listoffigures


\end{document}          
